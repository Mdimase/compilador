#variable a is float = 1 + pepe();  #esto genera un error, dado que no se puede invocar funciones en el ambito global "aclarado por german"
#variable cd is float = 1 + 1 / random();  esto genera un error, dado que no se puede invocar funciones en el ambito global "aclarado por german"
variable d is boolean = not false;
variable pol is float = 5-2;
variable hj is integer = 1.3;
# si invocara un parametro con nombre d,t, o cualquier otra variable declarada en el ambito global dispara una excepcion de nombre repetidos

function prueba_Funciones (c is integer, j is boolean=false) return float #a partir de la variable j, los demas parametros deben ser con valor por defecto, caso contrario, da error
    begin
        #puedo declarar variables locales a la funcion, siempre y cuando no pisen algun nombre de variables globales
        variable x is integer;
        if j == true then
            begin
                c=c-5;
                j = j or d;
            end;
        return c; # se convierte c de integer a float para que coincida con el tipo de retorno de la funcion
    end;

function pepe (a is float) return integer
    begin
        salamin(a);
        variable aux is integer= -p / a + salamin(prueba_Funciones(a)); # en esta invocacion ocurren varias conversiones de tipos
            if b == false and aux < 10-8 then
                write(4)
            else
                salamin(a);
    end;

function salamin(z is integer) return float
    begin
        while z < 12 do # las condiciones siempre evaluan que su resultado sea un bool
            begin
                writeln(z);
                z=z+1;
            end;
            # como no tiene un return, le agregamos uno implicitamente que retorna un valor por defecto segun el tipo de retorno de la funcion.
    end;

#variable t is float=2+3.56/p; dispara un error dado que p en este punto todavia no esta declarado
variable l is boolean=true;
variable p is integer = -1;
variable b is boolean;

main is

variable x is integer;
variable mj is float = .9999;
variable mk is float = 99.;
#x =  not x; no se puede hacer un not integer
#g = g and g; no se puede hacer un and entre aritmeticos y ademas, g todavia no esta declarada
#l = l + l; no se puede sumar entre tipos bool
#variable b is boolean=true;    # b ya esta declarada en global, no puede pisar su nombre

variable f is float= 0.45;
f = read_float();
variable fg is integer;
variable g is integer= 10 / fg;

if g==1 and b!= false then
    begin
        while fg<pepe(f) do
            begin
                #variable x is boolean; no puede pisar la x ya declarada
                variable lk is float;
                writeln(37.5 / prueba_Funciones(pepe(f)));
                fg=fg+1;
            end;
        #if 2+2 then b=false; #error porque la condicion no es booleana
        if fg == 12 then
            writeln("funciono bien");
    end;

#tranforma el for a su while equivalente
for g from 6 to 1 by 2 do
    begin
        write(g);
    end;

while 2 == 3 do
    begin
        write(5);
    end;
variable inv is float = 1 + pepe(2.3);

prueba_Funciones(g);
variable j is integer;
variable zz is boolean=false;

when g
    is < fg then g=1-pepe(5.2)
    #is == zz then g=23 #esto no se puede realizar porque comparamos un integer con un bool
    is != 15 then g=3
    else zz =true;

#g = salamin(g);
#salamin es una funcion que retorna un float, en este caso el return no se encuentra entonces devolvera un float por defecto (0.0), posteriormente se realiza una transformacion
#de bool a integer, quedando g con valor integer igual a 0

inv = (1*2 + 3.5 * 2) /2;
zz = true or false;

#write("Fin \"del\" programa\n");
end.