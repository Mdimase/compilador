
variable d is boolean = not false;
variable hj is integer = 1+65;
variable rt is float=5.56;
variable jk is float;
variable df is integer;
#variable yu is float = read_float(); HACER ESTO EN IRGLOBALVARIABLES
{
function prueba_Funciones (c is integer, j is boolean=false) return float #a partir de la variable j, los demas parametros deben ser con valor por defecto, caso contrario, da error
    begin
        #puedo declarar variables locales a la funcion, siempre y cuando no pisen algun nombre de variables globales
        variable x is integer;
        if j == true then
            begin
                c=c-5;
                j = j or d;
            end;
        return c; # se convierte c de integer a float para que coincida con el tipo de retorno de la funcion
    end;

function pepe (a is float) return integer
    begin
        salamin(a);
        variable aux is integer= -p / a + salamin(prueba_Funciones(a)); # en esta invocacion ocurren varias conversiones de tipos
            if b == false and aux < 10-8 then
                write(4)
            else
                salamin(a);
    end;

function salamin(z is integer) return float
    begin
        while z < 12 do # las condiciones siempre evaluan que su resultado sea un bool
            begin
                writeln(z);
                z=z+1;
            end;
            # como no tiene un return, le agregamos uno implicitamente que retorna un valor por defecto segun el tipo de retorno de la funcion.
    end;
}
variable p is integer = 15 + hj;
variable poyo is float = rt - jk;
variable b is boolean;
variable asd is float = -1.23;
variable nm is integer = -56;
variable l is boolean=not d;
variable kl is boolean = hj != df;

main is

variable j is integer;
variable zz is boolean=false;

end.