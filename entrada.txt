## Testeando compilador de Dimase Matias e Isea Maximiliano ##

#variable a is float = 1 + pepe();  esto genera un error, dado que no se puede invocar funciones en el ambito global "aclarado por german"
#variable cd is float = 1 + 1 / random();  esto genera un error, dado que no se puede invocar funciones en el ambito global "aclarado por german"

function prueba_Funciones (c is integer, j is boolean=false) return float
    begin
        c=c+2;
        if j == true then
            begin
                c=c+5;
                j = j or d;
            end;
        return c; # se convierte c de integer a float para que coincida con el tipo de retorno de la funcion
    end;

function pepe (a is float) return integer
    begin
        variable b is boolean;
            if b == false and a > 10 then
                a=-2*a
                else
                    write(a+a);
    end;

variable d is boolean;

main is

#x =  not x; no se puede hacer un not integer
#g = g and g; no se puede hacer un and entre aritmeticos
#x = x + x; no se puede sumar entre tipos bool
#pepe(b); tipo de parametro incorrecto
variable b is boolean=true;
variable fg is integer;
variable g is integer= 10/2;
variable f is float= 0.45;
read_float();

if g==1 and b!= false then
    begin
        while fg<12 do
            begin
                #variable x is boolean; no puede pisar la x ya declarada en main
                variable lk is float;
                writeln(37.5 / prueba_Funciones(pepe(f)));
                fg=fg+1;
            end;
        #if 2+2 then b=false; #error porque la condicion no es booleana
        if fg == 12 then writeln("funciono bien");
    end;

# tranforma el for a su while equivalente
for g from 1 to 5 do
    begin
        write(g);
    end;
prueba_Funciones(g);
variable x is float = 1 + pepe(2);
end.