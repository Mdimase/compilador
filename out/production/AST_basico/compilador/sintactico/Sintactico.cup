package compilador.sintactico;

import compilador.ast.base.*;
import compilador.ast.instrucciones.*;
import compilador.ast.operaciones.binarias.*;
import compilador.ast.operaciones.unarias.*;

import java.util.*;

import java_cup.runtime.*;

class Sintactico;

parser code
{:
    /*
    public void syntax_error(Symbol s) {
        System.out.println("Error en la línea " + (s.right+1) + ", columna " + s.left + ": "
            + SintacticoSym.terminalNames[s.sym] + "(" + s.value + ") no reconocido.");
    }   */

    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception{
            System.out.println("Error en la linea "+ (s.left+1)+ " Columna "+ s.right+ ". Valor simbolo '"
            +s.value+"' . Simbolo n° "+s.sym+ " no reconocido." );
        }

:}

action code
{:

:}

terminal MAIN,PUNTO,MAS, MENOS, MULTIPLICAR, DIVIDIR, APERTURA_PARENTESIS, CIERRE_PARENTESIS, MAYOR, MENOR, MAYOR_IGUAL, MENOR_IGUAL, IGUAL_IGUAL, DISTINTO, PUNTO_COMA, OR, AND, NOT, VARIABLE, IS, IGUAL,WHILE,DO,IF,THEN,ELSE,BEGIN,END,WRITE, WRITELN,WHEN, BREAK,CONTINUE,FUNCTION,RETURN,COMA,FOR,BY,TO,FROM;
terminal String IDENTIFICADOR, INTEGER_LITERAL, FLOAT_LITERAL,TRUE,FALSE,INTEGER,FLOAT,BOOLEAN, STRING_LITERAL;

non terminal Expresion invocacion_funciones,condicion,comparacion,expresion,exp_arit,exp_or,exp_and,exp_not, termino, factor, valor_constante;
//non terminal Comparacion comparacion;
non terminal List<Expresion> parametros_invocacion;
non terminal Programa programa;
//non terminal List<Declaracion> declaraciones;
non terminal Bloque bloque_main;
non terminal List<Sentencia> sentencias;
non terminal Sentencia sentencia, instruccion, bloque;
non terminal DeclaracionVariable declaracion_variable;
//non  terminal DeclaracionFuncion declaracion_funcion;
//non terminal List<Parametro> parametros, parametros_con_v_defecto;
//non terminal Parametro parametro,parametro_con_v_defecto;
non terminal Asignacion asignacion;
non terminal Tipo tipo;
non terminal Write write, writeln;
non terminal While while;
non terminal For for;
non terminal If if;
//non terminal InvocacionFuncion invocacion_funciones;
//non terminal When when;
//comparaciones_is?

precedence left IS; //para evitar shift/reduce en el when sin else
precedence left ELSE; // para evitar shift/reduce en el if

start with programa;

/*
programa ::=    lista_variables:lv sentencias:ss {:
                    lv.addAll(ss);  //para tener una sola lista
                    Bloque bloque = new Bloque(lv, "CUERPO", true); //bloque main
                    RESULT = new Programa(bloque);
                :};

lista_variables ::= VARS LLAVE_ABRE variables:vv LLAVE_CIERRA {:
                        RESULT = vv;
                    :} |
                    {:
                        RESULT = new ArrayList<>(); //corta la recursion e instancio
                    :}
                    ;

variables ::=   variables:vv variable:v {:
                    vv.addAll(v);
                    RESULT = vv;
                :} |
                variable:v
                {:
                    List<Sentencia> vs = new ArrayList<>(); //donde corta la recursion instancio
                    vs.addAll(v);
                    RESULT = vs;
                :}
                ;

sentencias ::=  sentencias:ss sentencia:s {:
                    ss.add(s);
                    RESULT = ss;
                :} |
                {:
                    List<Sentencia> ls = new ArrayList<>(); //donde corta la recursion instancio
                    RESULT = ls;              
                :}
                ;

tipo ::=    TIPO_FLOAT:t {:
                RESULT = Tipo.FLOAT;
            :} |
            TIPO_BOOL:t {: 
                RESULT = Tipo.BOOL;
            :} |
            TIPO_INT:t {:
                RESULT = Tipo.INTEGER;
            :};
//declaraciond e variables, esta asi xq el ejemplo soporta declaracion multiple a,b,c=10;
variable ::=    IDENTIFICADOR:id COLON tipo:t {:
                    List<DeclaracionVariable> dv = new ArrayList<>();
                    dv.add(new DeclaracionVariable(new Identificador(id, t), t));
                    RESULT = dv;
                :} |
                IDENTIFICADOR:id COMA variable:v {:
                    v.add(new DeclaracionVariable(new Identificador(id, v.get(0).getTipo()), v.get(0).getTipo()));
                    RESULT = v;
                :};
*/
//INICIO PROGRAMA NUESTRO
/*
programa ::= declaraciones:d bloque_main:bm{:
            RESULT = d+bm;
        :};
*/

//programa sin declaraciones anteriores al main is
programa ::=  bloque_main:bm{:
            RESULT = new Programa(bm);
        :};

bloque_main ::= MAIN IS sentencias:ss END PUNTO{:
            RESULT = new Bloque(ss,"MAIN",true);
            :};

/*
declaraciones ::= declaraciones:d declaracion_variable:dv PUNTO_COMA{:
            System.out.println("REGLA 2.1: declaraciones -> declaraciones declaracion_variable ;");
            RESULT=d+dv;
        :};

declaraciones ::= declaracion_variable:dv PUNTO_COMA{:
            System.out.println("REGLA 2.2: declaraciones -> declaracion_variable ;");
            RESULT=dv;
        :};

declaraciones ::= declaraciones:d declaracion_funcion:df {:
            System.out.println("REGLA 2.3: declaraciones -> declaraciones declaracion_funcion");
            RESULT=d+df;
        :};

declaraciones ::= declaracion_funcion:df {:
            RESULT=df;
        :};

declaracion_variable ::= VARIABLE IDENTIFICADOR:id IS tipo:t{:
            RESULT= new DeclaracionVariable(id,t);
        :};

declaracion_variable ::= VARIABLE IDENTIFICADOR:id IS tipo:t IGUAL expresion:e {:
            RESULT= new DeclaracionVariable(id,t,e);
        :};

tipo::= INTEGER:i {:
            RESULT= Tipo.INTEGER;
        :};

tipo::= FLOAT:f {:
            RESULT= Tipo.FLOAT;
        :};

tipo::= BOOLEAN:b {:
            RESULT= Tipo.BOOL;
        :};

//funcion con una sola sentencia y parametros
declaracion_funcion::= FUNCTION IDENTIFICADOR:id APERTURA_PARENTESIS parametros:p CIERRE_PARENTESIS RETURN tipo:t sentencia:s {:
            System.out.println("REGLA: 5.1: declaracion_funcion -> FUNCTION IDENTIFICADOR ( parametros ) RETURN tipo sentencia");
            RESULT="FUNCTION"+id+"("+p+")"+"RETURN"+t+s;
        :};

//funcion con una sola sentencia sin parametros
declaracion_funcion::= FUNCTION IDENTIFICADOR:id APERTURA_PARENTESIS CIERRE_PARENTESIS RETURN tipo:t sentencia:s {:
            System.out.println("REGLA: 5.2: declaracion_funcion -> FUNCTION IDENTIFICADOR () RETURN tipo sentencia");
            RESULT="FUNCTION"+id+"()"+"RETURN"+t+s;
        :};

parametros::= parametro:p COMA parametros:pp {:
            System.out.println("REGLA : parametros -> parametro COMA parametros");
            RESULT = p+","+pp;
        :};

parametros::= parametro_con_v_defecto:p parametros_con_v_defecto:pp {:
            System.out.println("REGLA : parametros -> parametro_con_v_defecto parametros_con_v_defecto");
            RESULT = p+pp;
        :};

parametros::= parametro:p {:
            System.out.println("REGLA : parametros -> parametro");
            RESULT = p;
        :};

parametros_con_v_defecto::= COMA parametro_con_v_defecto:p parametros_con_v_defecto:pp {:
            System.out.println("REGLA : parametros -> COMA parametro_con_v_defecto parametros_con_v_defecto");
            RESULT = ","+p+pp;
        :};

parametros_con_v_defecto::=  {:
            System.out.println("REGLA : parametros -> ");
        :};

parametro::= IDENTIFICADOR:id IS tipo:t {:
            System.out.println("REGLA 7.1: declaracion_parametro -> IDENTIFICADOR IS tipo");
            RESULT=id + "IS" +t;
        :};

parametro_con_v_defecto::= IDENTIFICADOR:id IS tipo:t IGUAL valor_defecto:v {:
            System.out.println("REGLA 7.2: declaracion_parametro -> IDENTIFICADOR IS tipo = valor_defecto");
            RESULT=id + "IS" +t + "=" +v;
        :};

valor_defecto::= INTEGER_LITERAL:i{:
        System.out.println("REGLA 8.1: valor_defecto -> INTEGER_LITERAL");
        RESULT=i;
:};

valor_defecto::= FLOAT_LITERAL:f{:
        System.out.println("REGLA 8.2: valor_defecto -> FLOAT_LITERAL");
        RESULT=f;
:};

valor_defecto::= TRUE:t{:
        System.out.println("REGLA 8.3: valor_defecto -> TRUE");
        RESULT=t;
:};

valor_defecto::= FALSE:f{:
        System.out.println("REGLA 8.4: valor_defecto -> FALSE");
        RESULT=f;
:};
*/

sentencias ::= sentencias:ss sentencia:s {:
            ss.add(s);
            RESULT= ss;
        :};

sentencias ::= sentencia:s {:
            List<Sentencia> ls = new ArrayList<>();
            ls.add(s);
            RESULT= ls;
        :};

sentencia ::= instruccion:i PUNTO_COMA {:
            RESULT=i;
        :};

instruccion ::= while:w {:
            RESULT=w;
        :};

instruccion ::= for:f {:
            RESULT=f;
        :};

instruccion ::= if:i {:
            RESULT=i;
        :};
/*
//pendiente
instruccion ::= when:w{:
            RESULT=w;
        :};
*/

instruccion ::= invocacion_funciones:i {:
            RESULT=(Sentencia) i;
        :};

instruccion ::= asignacion:a {:
            RESULT=a;
        :};

instruccion ::= declaracion_variable:d {:
            RESULT=d;
        :};

instruccion ::= BREAK{:
            RESULT= new Break("BREAK");
        :};

instruccion ::= CONTINUE{:
            RESULT= new Continue("CONTINUE");
        :};

instruccion ::= RETURN expresion:e {:
            RESULT= new Return(e);
        :};

instruccion ::= write:w {:
            RESULT=w;
        :};

instruccion ::= writeln:wln {:
            RESULT=wln;
        :};

instruccion ::= bloque:b {:
            RESULT=b;
        :};

bloque ::= BEGIN sentencias:ss END{:
            RESULT = new Bloque (ss,"BLOQUE",false);
            :};

//sacarlo cuando hagamos las declaraciones fuera de main is
declaracion_variable ::= VARIABLE IDENTIFICADOR:id IS tipo:t{:
            Identificador identificador = new Identificador(id,t);
            RESULT= new DeclaracionVariable(identificador,t);
        :};

declaracion_variable ::= VARIABLE IDENTIFICADOR:id IS tipo:t IGUAL expresion:e {:
            Identificador identificador = new Identificador(id,t);
            RESULT= new DeclaracionVariable(identificador,t,e);
        :};

asignacion ::=  IDENTIFICADOR:id IGUAL expresion:e {:
                   Identificador ident = new Identificador(id);
                   RESULT = new Asignacion(ident,e);
              :};

while::= WHILE condicion:c DO instruccion:i {:
            List<Sentencia> aux = new ArrayList<Sentencia>();
            aux.add(i);
            Bloque bloque = new Bloque(aux,"BLOQUE_WHILE",false);
            RESULT= new While("WHILE",c, bloque);
        :};

for::= FOR IDENTIFICADOR:id FROM INTEGER_LITERAL:f TO INTEGER_LITERAL:t BY INTEGER_LITERAL:b DO instruccion:i{:

            Identificador identificador = new Identificador(id);
            Constante from = new Constante(f, Tipo.INTEGER);
            Constante to = new Constante(t, Tipo.INTEGER);
            Constante by = new Constante(b, Tipo.INTEGER);
            List<Sentencia> aux = new ArrayList<Sentencia>();
            aux.add(i);
            Bloque bloque = new Bloque(aux,"FOR",false);
            RESULT= new For(identificador,from,to,by,bloque);

            /* FOR -> WHILE esta bien aca, no me grafica BLOQUE en el while interno
            List<Sentencia> cuerpoFor = new ArrayList<Sentencia>(); //lista de sentencias del bloque principal
            Expresion from = new Constante(f, Tipo.INTEGER);    //constante from
            Identificador identificador = new Identificador(id);    //identificador
            Sentencia as = new Asignacion(identificador,from);  //primera asignacion id=f;
            cuerpoFor.add(as);  //agrego esa sentencia al bloque principal

            List<Sentencia> aux = new ArrayList<Sentencia>();   //lista de sentencias del bloque while interno
            aux.add(i); //agrego todas las sentencias que eran del for original
            Expresion by = new Constante(b, Tipo.INTEGER);  //constante by
            Expresion exp = new Suma(identificador,by); //expresion usada en la asignacion id+by;
            Sentencia asig = new Asignacion(identificador,exp); // asignacion id=id+by;
            aux.add(asig);  //agrego la asignacion a la lista de sentencias del bloque while interno

            Expresion to = new Constante(t,Tipo.INTEGER);   //constante to
            Expresion condicion = new MenorIgual(identificador,to); //condicion del while interno

            Bloque bloque = new Bloque(aux,"BLOQUE",false);  //bloque de sentencias del while interno

            While w = new While("WHILE",condicion,bloque);  // while interno completo
            cuerpoFor.add(w);   //agrego el while completo a la lista de sentencias del cuerpo de mi for original
            RESULT = new Bloque (cuerpoFor,"FOR->WHILE",false);
            */

        :};

for::= FOR IDENTIFICADOR:id FROM INTEGER_LITERAL:f TO INTEGER_LITERAL:t DO instruccion:i{:

            Identificador identificador = new Identificador(id);
            Constante from = new Constante(f, Tipo.INTEGER);
            Constante to = new Constante(t, Tipo.INTEGER);
            Constante by = new Constante(String.valueOf(1), Tipo.INTEGER);
            List<Sentencia> aux = new ArrayList<Sentencia>();
            aux.add(i);
            Bloque bloque = new Bloque(aux,"FOR",false);
            RESULT= new For(identificador,from,to,by,bloque);

            /* FOR -> WHILE esta bien aca, no me grafica BLOQUE en el while interno
            List<Sentencia> cuerpoFor = new ArrayList<Sentencia>(); //lista de sentencias del bloque principal
            Expresion from = new Constante(f, Tipo.INTEGER);    //constante from
            Identificador identificador = new Identificador(id);    //identificador
            Sentencia as = new Asignacion(identificador,from);  //primera asignacion id=f;
            cuerpoFor.add(as);  //agrego esa sentencia al bloque principal

            List<Sentencia> aux = new ArrayList<Sentencia>();   //lista de sentencias del bloque while interno
            aux.add(i); //agrego todas las sentencias que eran del for original
            Expresion by = new Constante(String.valueOf(1), Tipo.INTEGER);  //constante by
            Expresion exp = new Suma(identificador,by); //expresion usada en la asignacion id+by;
            Sentencia asig = new Asignacion(identificador,exp); // asignacion id=id+by;
            aux.add(asig);  //agrego la asignacion a la lista de sentencias del bloque while interno

            Expresion to = new Constante(t,Tipo.INTEGER);   //constante to
            Expresion condicion = new MenorIgual(identificador,to); //condicion del while interno

            Bloque bloque = new Bloque(aux,"BLOQUE",false);  //bloque de sentencias del while interno

            While w = new While("WHILE",condicion,bloque);  // while interno completo
            cuerpoFor.add(w);   //agrego el while completo a la lista de sentencias del cuerpo de mi for original
            RESULT = new Bloque (cuerpoFor,"FOR->WHILE",false);
            */
        :};

// falla en una expresion
invocacion_funciones ::= IDENTIFICADOR:id APERTURA_PARENTESIS parametros_invocacion:p CIERRE_PARENTESIS{:
            Identificador identificador = new Identificador(id);
            RESULT = new InvocacionFuncion(identificador,p);
        :};

//falla en una expresion
invocacion_funciones ::= IDENTIFICADOR:id APERTURA_PARENTESIS CIERRE_PARENTESIS {:
            Identificador identificador = new Identificador(id);
            RESULT = new InvocacionFuncion(identificador);
        :};

parametros_invocacion::= parametros_invocacion:pi COMA expresion:e {:
            pi.add(e);
            RESULT = pi;
        :};

parametros_invocacion::= expresion:e {:
            List<Expresion> exp = new ArrayList();
            exp.add(e);
            RESULT= exp;
        :};

write::= WRITE APERTURA_PARENTESIS expresion:e CIERRE_PARENTESIS{:
            RESULT = new Write(e);
        :};

write ::= WRITE APERTURA_PARENTESIS STRING_LITERAL CIERRE_PARENTESIS {:
            Write w = new Write();
            w.setEsString(true);
            RESULT = w;
            :};

writeln ::= WRITELN APERTURA_PARENTESIS expresion:e CIERRE_PARENTESIS{:
            RESULT = new Write(e, true);
            :};

writeln ::= WRITELN APERTURA_PARENTESIS STRING_LITERAL CIERRE_PARENTESIS{:
            Write w = new Write(true);
            w.setEsString(true);
            RESULT = w;
            :};

tipo::= INTEGER:i {:
            RESULT= Tipo.INTEGER;
        :};

tipo::= FLOAT:f {:
            RESULT= Tipo.FLOAT;
        :};

tipo::= BOOLEAN:b {:
            RESULT= Tipo.BOOL;
        :};

/*
when::= WHEN expresion:e comparaciones_is:ci ELSE instruccion:i{:
            System.out.println("REGLA 20.1: when -> WHEN expresion comparaciones_is ELSE instruccion");
            RESULT="WHEN"+e+ci+"ELSE"+i;
        :};

when::= WHEN expresion:e comparaciones_is:ci {:
            System.out.println("REGLA 20.2: when -> WHEN expresion comparaciones_is");
            RESULT="WHEN"+e+ci;
        :};

comparaciones_is::= comparaciones_is:ci1 IS comparador:c expresion:e THEN instruccion:i{:
            System.out.println("REGLA 21.1: comparaciones_is -> comparaciones_is IS comparador expresion THEN instruccion");
            RESULT=ci1+"IS"+c+e+"THEN"+i;
        :};

comparaciones_is::= IS comparador:c expresion:e THEN instruccion:i{:
            System.out.println("REGLA 21.2: comparaciones_is -> IS comparador expresion THEN instruccion ");
            RESULT="IS"+c+e+"THEN"+i;
        :};
*/

// if una instruccion sin; + else una instruccion con ; al final(lo agrega la sentencia que engloba al if)
if ::= IF condicion:c THEN instruccion:i1 ELSE instruccion:i2 {:
            List<Sentencia> sentenciasIf = new ArrayList<Sentencia>();
            sentenciasIf.add(i1);
            Bloque bloqueThen = new Bloque(sentenciasIf,"BLOQUE_THEN",false);
            List<Sentencia> sentenciasElse = new ArrayList<Sentencia>();
            sentenciasElse.add(i2);
            Bloque bloqueElse = new Bloque(sentenciasElse,"BLOQUE_ELSE",false);
            RESULT= new If("IF/ELSE",c, bloqueThen, bloqueElse);
        :};

// if una instruccion con ; al final(lo agrega la sentencia que engloba al if)
if ::= IF condicion:c THEN instruccion:i {:
            List<Sentencia> sentenciasIf = new ArrayList<Sentencia>();
            sentenciasIf.add(i);
            Bloque bloqueThen = new Bloque(sentenciasIf,"BLOQUE_THEN",false);
            RESULT= new If("IF",c, bloqueThen);
        :};

condicion ::= expresion:e {:
            RESULT=e;
        :};

expresion::= exp_or:e {:
            RESULT=e;
        :};

exp_or ::= exp_or:e OR exp_and:ea {:
            RESULT= new Or(e, ea);
        :};

exp_or ::= exp_and:ea {:
            RESULT=ea;
        :};

exp_and ::= exp_and:ea AND exp_not:en {:
            RESULT= new And(ea,en);
        :};

exp_and ::= exp_not:en {:
            RESULT=en;
        :};

exp_not ::= NOT exp_not:en {:
            RESULT= new Not(en);
        :};

exp_not ::= comparacion:c {:
            RESULT= c;
        :};

comparacion ::= exp_arit:e1 IGUAL_IGUAL exp_arit:e2  {:
            RESULT = new IgualIgual(e1,e2);
        :};

comparacion ::= exp_arit:e1 DISTINTO exp_arit:e2  {:
            RESULT = new Distinto(e1,e2);
        :};

comparacion ::= exp_arit:e1 MAYOR_IGUAL exp_arit:e2  {:
            RESULT = new MayorIgual(e1,e2);
        :};

comparacion ::= exp_arit:e1 MENOR_IGUAL exp_arit:e2  {:
            RESULT = new MenorIgual(e1,e2);
        :};

comparacion ::= exp_arit:e1 MENOR exp_arit:e2  {:
            RESULT = new Menor(e1,e2);
        :};

comparacion ::= exp_arit:e1 MAYOR exp_arit:e2  {:
            RESULT = new Mayor(e1,e2);
        :};

comparacion ::= exp_arit:e {:
            RESULT= e;
        :};

exp_arit ::= exp_arit:e MAS termino:t {:
            RESULT = new Suma(e, t);
            :};

exp_arit ::= exp_arit:e MENOS termino:t {:
            RESULT = new Resta(e, t);
            :};

exp_arit ::= termino:t{:
            RESULT = t;
            :};

termino ::= termino:t MULTIPLICAR factor:f{:
            RESULT = new Multiplicacion(t, f);
            :};

termino ::= termino:t DIVIDIR factor:f{:
            RESULT = new Division(t, f);
            :};

termino ::= factor:f{:
            RESULT = f;
            :};

factor ::= APERTURA_PARENTESIS exp_or:e CIERRE_PARENTESIS {:
            RESULT = e;
            :};

factor ::= IDENTIFICADOR:id {:
            RESULT = new Identificador(id);
            :};

factor ::= INTEGER_LITERAL:ent {:
            RESULT = new Constante(ent, Tipo.INTEGER);
            :};

factor ::= FLOAT_LITERAL:f {:
            RESULT = new Constante(f, Tipo.FLOAT);
            :};

factor ::= TRUE:t {:
            RESULT = new Constante(t, Tipo.BOOL);;
            :};

factor ::= FALSE:f {:
            RESULT = new Constante(f, Tipo.BOOL);
            :};

factor ::= invocacion_funciones:i {:
            RESULT = i;
            :};

factor ::= MENOS factor:f {:
            RESULT = new MenosUnario(f);
            :};
